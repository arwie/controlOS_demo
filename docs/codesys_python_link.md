# CODESYS ↔ Python Link

Real-time variable exchange between a CODESYS application and a Python application running in parallel, using POSIX shared memory and a semaphore.

## Architecture

Two IPC primitives are created by CODESYS at startup and opened by Python:

- **Shared memory** (`/dev/shm/codesys`) — carries the actual data
- **Semaphore** (`/codesys`) — signals Python that a sync cycle completed

### Shared Memory Layout

```
┌──────────────────────────────────────────┐
│  1 byte    sync_flag                     │
│  N bytes   AppCmd   (Python → CODESYS)   │
│  M bytes   AppFbk   (CODESYS → Python)   │
└──────────────────────────────────────────┘
```

`sync_flag` is written by Python to `1` to indicate new command data is ready. CODESYS reads it every cycle, processes commands if set, then writes feedback and releases the semaphore.

---

## Sync Protocol

CODESYS drives the sync cycle. The semaphore acts as a "cycle done" signal from CODESYS to Python, not a mutual-exclusion lock.

### Startup (CODESYS `PrepareStart`)

```
SysSemProcessCreate('codesys', ...)
SysSharedMemoryCreate('codesys', ...)
SysSharedMemoryWrite(shm, 0, ADR(sync=0), ...)
SysSemProcessLeave(sem)   ← releases semaphore once, so it starts available
```

### Per-Cycle Sequence

```
CODESYS cycle                              Python background thread
─────────────────────────────────────────────────────────────────────
read sync_flag from shm
if sync_flag > 0:
  read cmd from shm
run application logic (main)
if sync_flag > 0:
  write fbk to shm
  clear sync_flag to 0
  SysSemProcessLeave(sem) ─────────────► sem.acquire() returns
                                         shm_sync() scheduled on event loop:
                                           copy cmd → shm
                                           copy shm fbk → fbk
                                           set sync_flag = 1
                                           fire _sync_trigger
read sync_flag from shm                  (asyncio awaitables resume)
...
```

Key points:

- If `sync_flag` is `0` when CODESYS reads it (Python was slow), the cycle is skipped for data exchange — `missed` counter increments, semaphore is not released, Python does not get a trigger that cycle.
- `shm_sync()` atomically updates both directions and pulses `_sync_trigger`.
- The semaphore is binary and non-blocking on the CODESYS side (`SysSemProcessLeave` is a post, not acquire).

### `sync()` — Waiting for a Full Round-Trip

```python
async def sync():
    await _sync_trigger.wait()  # cmd → CODESYS: our cmd data is now in shm
    await _sync_trigger.wait()  # CODESYS → fbk: CODESYS has processed cmd and fbk is updated
```

Calling `await codesys.sync()` waits for **two** trigger fires, ensuring:
1. The current `cmd` values have been written to shared memory (CODESYS will read them next cycle).
2. CODESYS has completed one full cycle after reading those commands, and the resulting `fbk` is now in the Python-side struct.

Use `sync()` after clearing a command field to guarantee CODESYS has acknowledged the reset before moving on.

### `poll()` — Condition Polling Synchronized to CODESYS Cycles

```python
poll = partial(app.poll, period=_sync_trigger)
```

`codesys.poll(condition)` checks the condition after every sync trigger — i.e., after each CODESYS cycle that completed a data exchange. This avoids busy-waiting and ensures checks happen on fresh `fbk` data.

---

## Data Structures

Three structures define the interface. They are declared in IEC 61131-3 structured text on the CODESYS side and mirrored as Python `ctypes.Structure` subclasses generated by the export script.

### Structure roles

| Struct   | Direction            | Transport                                  |
|----------|----------------------|--------------------------------------------|
| `AppCfg` | Python → CODESYS     | File (`/run/codesys/cfg`), once at startup |
| `AppCmd` | Python → CODESYS     | Shared memory, every cycle                 |
| `AppFbk` | CODESYS → Python     | Shared memory, every cycle                 |

---

### `AppCfg` — Configuration

Written once before CODESYS starts; CODESYS reads the file in `PrepareStart` and never writes back.

**CODESYS** (`AppCfg.txt`):
```pascal
TYPE AppCfg:
STRUCT
    robot_vel : LREAL;
    robot_acc : LREAL;
    robot_jrk : LREAL;
    conv_acc  : LREAL;
    conv_jrk  : LREAL;
END_STRUCT
END_TYPE
```

**Generated Python** (`codesys_types/AppCfg.py`):
```python
from ctypes import *  #type:ignore
class AppCfg(Structure):
    robot_vel: float
    robot_acc: float
    robot_jrk: float
    conv_acc: float
    conv_jrk: float
    _fields_ = [
        ('robot_vel', c_double),
        ('robot_acc', c_double),
        ('robot_jrk', c_double),
        ('conv_acc',  c_double),
        ('conv_jrk',  c_double),
    ]
```

---

### `AppCmd` — Commands

**CODESYS** (`AppCmd.txt`):
```pascal
TYPE AppCmd:
STRUCT
    co               : CoCmd;
    rbt_power        : BOOL;
    rbt_override     : LREAL;
    rbt_move         : INT;
    rbt_move_coord   : ARRAY [0..2] OF LREAL;
    rbt_move_fvel    : LREAL;
    conv_power       : BOOL;
    conv_move        : INT;
    conv_move_vel    : LREAL;
    io               : ARRAY [0..128] OF BOOL;
END_STRUCT
END_TYPE
```

**Generated Python** (`codesys_types/AppCmd.py`):
```python
from ctypes import *  #type:ignore
from .CoCmd import CoCmd
class AppCmd(Structure):
    co: CoCmd
    rbt_power: bool
    rbt_override: float
    rbt_move: int
    rbt_move_coord: list[float]
    rbt_move_fvel: float
    conv_power: bool
    conv_move: int
    conv_move_vel: float
    io: list[bool]
    _fields_ = [
        ('co',               CoCmd),
        ('rbt_power',        c_bool),
        ('rbt_override',     c_double),
        ('rbt_move',         c_int16),
        ('rbt_move_coord',   c_double * 3),
        ('rbt_move_fvel',    c_double),
        ('conv_power',       c_bool),
        ('conv_move',        c_int16),
        ('conv_move_vel',    c_double),
        ('io',               c_bool * 129),
    ]
```

---

### `AppFbk` — Feedback

**CODESYS** (`AppFbk.txt`):
```pascal
TYPE AppFbk:
STRUCT
    co             : CoFbk;
    init_done      : BOOL;
    rbt_axes       : ARRAY [0..2] OF LREAL;
    rbt_pos        : ARRAY [0..2] OF LREAL;
    rbt_powered    : BOOL;
    rbt_move_done  : BOOL;
    rbt_move_error : BOOL;
    conv_pos       : LREAL;
    conv_powered   : BOOL;
    conv_move_done : BOOL;
    conv_move_error: BOOL;
    io             : ARRAY [0..128] OF BOOL;
END_STRUCT
END_TYPE
```

**Generated Python** (`codesys_types/AppFbk.py`):
```python
from ctypes import *  #type:ignore
from .CoFbk import CoFbk
class AppFbk(Structure):
    co: CoFbk
    init_done: bool
    rbt_axes: list[float]
    rbt_pos: list[float]
    rbt_powered: bool
    rbt_move_done: bool
    rbt_move_error: bool
    conv_pos: float
    conv_powered: bool
    conv_move_done: bool
    conv_move_error: bool
    io: list[bool]
    _fields_ = [
        ('co',             CoFbk),
        ('init_done',      c_bool),
        ('rbt_axes',       c_double * 3),
        ('rbt_pos',        c_double * 3),
        ('rbt_powered',    c_bool),
        ('rbt_move_done',  c_bool),
        ('rbt_move_error', c_bool),
        ('conv_pos',       c_double),
        ('conv_powered',   c_bool),
        ('conv_move_done', c_bool),
        ('conv_move_error',c_bool),
        ('io',             c_bool * 129),
    ]
```

---

### Nested structs — `CoCmd` / `CoFbk`

Nested struct types referenced inside `AppCmd`/`AppFbk` are exported as separate files and imported at the top of the parent. Here `CoCmd` and `CoFbk` carry the EtherCAT/CANopen SDO channel.

**CODESYS** (`CoCmd.txt` / `CoFbk.txt`):
```pascal
TYPE CoCmd:
STRUCT
    func       : INT;   // >0: EtherCAT, <0: CANopen, 0: idle
    master     : USINT;
    slave      : UINT;
    index      : WORD;
    subIndex   : BYTE;
    dataLength : USINT;
    data       : DWORD;
END_STRUCT
END_TYPE

TYPE CoFbk:
STRUCT
    data  : DWORD;
    done  : BOOL;
    error : BOOL;
END_STRUCT
END_TYPE
```

---

### The generated class pattern explained

Each generated class uses two parallel declarations for the same set of fields:

**`_fields_`** — the ctypes machinery. A list of `(name, ctype)` pairs that `ctypes.Structure` uses to determine the binary memory layout. The ctypes here map directly to the IEC 61131-3 types and must match exactly so the struct overlays the shared memory correctly.

---

## Type Export Script

`codesys/export_types.py` runs inside the CODESYS scripting engine and generates the Python `ctypes` classes automatically from the project's IEC type declarations, eliminating manual duplication.

```
export_types = ['AppCfg', 'AppCmd', 'AppFbk']
```

Nested struct types (e.g. `CoCmd`, `CoFbk`) are discovered transitively and exported as separate files. Arrays map to `ctype * N`. The output is written to a `codesys_types/` package next to the project file, then placed at `code/shared/codesys_types/` in the Python codebase.

IEC type mapping:

| IEC 61131-3     | ctypes      | Python hint |
|-----------------|-------------|-------------|
| `BOOL`          | `c_bool`    | `bool`      |
| `SINT`          | `c_int8`    | `int`       |
| `INT`           | `c_int16`   | `int`       |
| `DINT`          | `c_int32`   | `int`       |
| `LINT`          | `c_int64`   | `int`       |
| `USINT`/`BYTE`  | `c_uint8`   | `int`       |
| `UINT` /`WORD`  | `c_uint16`  | `int`       |
| `UDINT`/`DWORD` | `c_uint32`  | `int`       |
| `ULINT`/`LWORD` | `c_uint64`  | `int`       |
| `REAL`          | `c_float`   | `float`     |
| `LREAL`         | `c_double`  | `float`     |

---

## Python API (`shared.app.codesys`)

### Module-level objects

| Name  | Type         | Description                                   |
|-------|--------------|-----------------------------------------------|
| `cfg` | `AppCfg`     | Configuration struct, written at startup      |
| `cmd` | `AppCmd`     | Command struct, written to shm each cycle     |
| `fbk` | `AppFbk`     | Feedback struct, read from shm each cycle     |

### `exec()` — Async Context Manager

Starts CODESYS, establishes the shared memory link, and tears everything down on exit.

```python
async with codesys.exec():
    # CODESYS is running and synced
    await app.poll(lambda: codesys.fbk.init_done)
    ...
```

Internally:
1. Writes `bytes(cfg)` to `/run/codesys/cfg`.
2. Cold-resets and starts the CODESYS application via the PLC shell socket.
3. Waits up to 30 s for `/dev/shm/codesys` to appear.
4. Opens shared memory and semaphore, maps memory with `mmap`.
5. Starts `shm_sync_loop` background thread.
6. Waits for the first sync (initial handshake) before yielding.
7. On exit: stops the sync thread (releases semaphore to unblock it), flushes pending scheduled callbacks.

### `sync()` — Await Full Round-Trip

```python
await codesys.sync()
```

Waits for two consecutive `shm_sync` calls (= one cmd→CODESYS + one CODESYS→fbk cycle). Use this after modifying `cmd` fields that represent one-shot commands to ensure CODESYS has seen the value and responded before you clear it.

### `poll(condition, ...)` — Cycle-Synchronized Polling

```python
await codesys.poll(lambda: codesys.fbk.rbt_powered, timeout=3)
```

Equivalent to `app.poll` but uses `_sync_trigger` as the wait period, so the condition is checked on every fresh `fbk` update from CODESYS.

### `runstop_switch(run)` — PLC Run/Stop

```python
codesys.runstop_switch(True)   # RUN
codesys.runstop_switch(False)  # STOP
```

Writes to `/var/opt/codesysextension/runstop.switch`.

### `shell_cmd(cmd)` — PLC Shell

```python
result = await codesys.shell_cmd('resetprgcold application')
```

Sends a command to the CODESYS runtime shell via Unix socket.

---

## EtherCAT and CANopen SDO Access

`AppCmd.co` and `AppFbk.co` carry SDO requests through the shared memory channel, letting Python read/write device object dictionary entries via CODESYS.

```
cmd.co.func      INT   >0: EtherCAT, <0: CANopen, 0: idle
cmd.co.master    USINT network/master number
cmd.co.slave     UINT  slave/device address
cmd.co.index     WORD  object index
cmd.co.subIndex  BYTE  subindex
cmd.co.dataLength USINT data length in bytes (write only)
cmd.co.data      DWORD data (write only)

fbk.co.data      DWORD result data (read)
fbk.co.done      BOOL  operation completed
fbk.co.error     BOOL  operation failed
```

### `EthercatDevice` / `CanopenDevice`

```python
from shared.app.codesys import CanopenDevice

class MyDrive(CanopenDevice):
    def __init__(self, slave):
        super().__init__(slave, master=1)

drive = MyDrive(slave=3)

# Read object 0x6064:0 as signed 32-bit
pos = await drive.sdo_read((0x6064, 0), c_int32)

# Write object 0x6073:0
await drive.sdo_write((0x6073, 0), c_uint16(500))
```

`EthercatDevice` uses positive `func` values; `CanopenDevice` negates them. SDO operations hold `_co_lock` (a module-level asyncio lock) to prevent concurrent access.

After each SDO operation the method calls `await sync()` to clear `cmd.co.func` and wait for CODESYS to acknowledge the reset.

---

## Usage Patterns

### Reading feedback and writing commands

```python
# cmd fields are plain ctypes assignments — effective on next sync
codesys.cmd.rbt_power = True
codesys.cmd.rbt_override = 0.5

# fbk fields are always up-to-date after a trigger
powered = codesys.fbk.rbt_powered
```

### Waiting for a condition in sync with CODESYS

```python
if not await codesys.poll(lambda: codesys.fbk.rbt_powered, timeout=3):
    raise Exception('Robot did not power on')
```

### Issuing a one-shot command and waiting for completion

```python
codesys.cmd.rbt_move = 1
try:
    if not await codesys.poll(
        lambda: codesys.fbk.rbt_move_done,
        abort=lambda: codesys.fbk.rbt_move_error,
    ):
        raise Exception('Move failed')
finally:
    codesys.cmd.rbt_move = 0
    await codesys.sync()   # wait for CODESYS to see rbt_move=0
```

### Using configuration before startup

```python
# robot.py — runs before codesys.exec() is entered
codesys.cfg.robot_vel = 2000
codesys.cfg.robot_acc = 20000
```

### Full application entry point

```python
async with codesys.exec():
    await app.poll(lambda: codesys.fbk.init_done)  # wait for PLC init
    async with sim.exec():
        await operation()
```
